// Generated by CoffeeScript 1.3.1
(function() {

  window.define = function(moduleName, dependencyNames, moduleFactory) {
    if (window.modules == null) {
      window.modules = {};
    }
    if (window.modules[moduleName] == null) {
      return window.modules[moduleName] = {
        name: moduleName,
        dependencyNames: dependencyNames,
        factory: moduleFactory
      };
    } else {
      throw "Module " + moduleName + " is already defined.";
    }
  };

  window.load = function(moduleName, loadedModules) {
    var dependencies, dependencyName, module;
    if (window.modules == null) {
      throw "No modules have been defined.";
    }
    if (window.modules[moduleName] == null) {
      throw "A module called " + moduleName + " does not exist.";
    }
    if (loadedModules == null) {
      loadedModules = {};
    }
    if (loadedModules[moduleName] == null) {
      module = window.modules[moduleName];
      dependencies = (function() {
        var _i, _len, _ref, _results;
        _ref = module.dependencyNames;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dependencyName = _ref[_i];
          if (modules[dependencyName] == null) {
            throw ("A module called \"" + dependencyName + "\" (defined as a ") + ("dependency in \"" + moduleName + "\") does not exist.");
          }
          _results.push(load(dependencyName, loadedModules));
        }
        return _results;
      })();
      loadedModules[moduleName] = module.factory.apply(void 0, dependencies);
    }
    return loadedModules[moduleName];
  };

  define("Transform2d", [], function() {
    var module;
    return module = {
      identityMatrix: function() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      },
      translationMatrix: function(v) {
        return [[1, 0, v[0]], [0, 1, v[1]], [0, 0, 1]];
      },
      rotationMatrix: function(angle) {
        return [[Math.cos(angle), -Math.sin(angle), 0], [Math.sin(angle), Math.cos(angle), 0], [0, 0, 1]];
      },
      scalingMatrix: function(factor) {
        return [[factor, 0, 0], [0, factor, 0], [0, 0, 1]];
      }
    };
  });

  define("Entities", [], function() {
    var module;
    return module = {
      createEntity: function(factories, components, type, args) {
        var component, componentName, entity, _ref, _results;
        entity = factories[type](args);
        _ref = entity.components;
        _results = [];
        for (componentName in _ref) {
          component = _ref[componentName];
          if (!components[componentName]) {
            components[componentName] = {};
          }
          _results.push(components[componentName][entity.id] = component);
        }
        return _results;
      },
      destroyEntity: function(components, entityId) {
        var componentMap, componentType, _results;
        _results = [];
        for (componentType in components) {
          componentMap = components[componentType];
          _results.push(delete componentMap[entityId]);
        }
        return _results;
      }
    };
  });

  define("Images", [], function() {
    var module;
    return module = {
      loadImages: function(imagePaths, onLoad) {
        var image, imagePath, images, numberOfImagesToLoad, _i, _len, _results;
        images = {};
        numberOfImagesToLoad = imagePaths.length;
        _results = [];
        for (_i = 0, _len = imagePaths.length; _i < _len; _i++) {
          imagePath = imagePaths[_i];
          image = new Image;
          images[imagePath] = image;
          image.onload = function() {
            numberOfImagesToLoad -= 1;
            if (numberOfImagesToLoad === 0) {
              return onLoad(images);
            }
          };
          _results.push(image.src = imagePath);
        }
        return _results;
      },
      process: function(rawImages) {
        var imageId, images, rawImage;
        images = {};
        for (imageId in rawImages) {
          rawImage = rawImages[imageId];
          images[imageId] = {
            rawImage: rawImage,
            positionOffset: [-rawImage.width / 2, -rawImage.height / 2],
            orientationOffset: 0
          };
        }
        return images;
      }
    };
  });

  define("VelocityVerletIntegrator", [], function() {
    var module;
    return module = {
      integrate: function(bodies, passedTimeInS) {
        var body, entityId, force, movementFromAcceleration, movementFromVelocity, newAcceleration, velocityChange, _i, _len, _ref, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          newAcceleration = [0, 0];
          _ref = body.forces;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            force = _ref[_i];
            Vec2.scale(force, 1 / body.mass);
            Vec2.add(newAcceleration, force);
          }
          body.forces.length = 0;
          movementFromVelocity = Vec2.copy(body.velocity);
          Vec2.scale(movementFromVelocity, passedTimeInS);
          movementFromAcceleration = Vec2.copy(body.acceleration);
          Vec2.scale(movementFromAcceleration, 0.5);
          Vec2.scale(movementFromAcceleration, passedTimeInS * passedTimeInS);
          Vec2.add(body.position, movementFromVelocity);
          Vec2.add(body.position, movementFromAcceleration);
          velocityChange = Vec2.copy(body.acceleration);
          Vec2.add(velocityChange, newAcceleration);
          Vec2.scale(velocityChange, 0.5);
          Vec2.scale(velocityChange, passedTimeInS);
          Vec2.add(body.velocity, velocityChange);
          _results.push(body.acceleration = newAcceleration);
        }
        return _results;
      }
    };
  });

  define("EulerIntegrator", [], function() {
    var module;
    return module = {
      integrate: function(bodies, passedTimeInS) {
        var body, entityId, force, newAcceleration, positionChange, velocityChange, _i, _len, _ref, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          newAcceleration = [0, 0];
          _ref = body.forces;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            force = _ref[_i];
            Vec2.scale(force, 1 / body.mass);
            Vec2.add(newAcceleration, force);
          }
          body.forces.length = 0;
          body.acceleration = newAcceleration;
          velocityChange = Vec2.copy(body.acceleration);
          Vec2.scale(velocityChange, passedTimeInS);
          Vec2.add(body.velocity, velocityChange);
          positionChange = Vec2.copy(body.velocity);
          Vec2.scale(positionChange, passedTimeInS);
          _results.push(Vec2.add(body.position, positionChange));
        }
        return _results;
      }
    };
  });

  define("CollisionResponse", [], function() {
    var module;
    return module = {
      handleContacts: function(contacts, bodies, parameters) {
        var b, bodyA, bodyB, contact, damping, force, k, negativeForce, relativeVelocity, spring, _i, _len, _results;
        k = parameters.k;
        b = parameters.b;
        _results = [];
        for (_i = 0, _len = contacts.length; _i < _len; _i++) {
          contact = contacts[_i];
          bodyA = bodies[contact.bodyIds[0]];
          bodyB = bodies[contact.bodyIds[1]];
          relativeVelocity = Vec2.copy(bodyA.velocity);
          Vec2.subtract(relativeVelocity, bodyB.velocity);
          spring = Vec2.copy(contact.normal);
          Vec2.scale(spring, -k * contact.depth);
          damping = Vec2.copy(contact.normal);
          Vec2.scale(damping, b * Vec2.dot(contact.normal, relativeVelocity));
          force = Vec2.copy(spring);
          Vec2.add(force, damping);
          Vec2.scale(force, 0.5);
          negativeForce = Vec2.copy(force);
          Vec2.scale(negativeForce, -1);
          bodyA.forces.push(force);
          _results.push(bodyB.forces.push(negativeForce));
        }
        return _results;
      }
    };
  });

  define("Physics", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      parameters: {
        collisionResponse: {
          k: 10000,
          b: 0
        }
      },
      createBody: function() {
        var body;
        return body = {
          position: [0, 0],
          velocity: [0, 0],
          acceleration: [0, 0],
          orientation: 0,
          angularVelocity: 0,
          forces: [],
          mass: 1
        };
      },
      integrateOrientation: function(bodies, passedTimeInS) {
        var body, entityId, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          _results.push(body.orientation += body.angularVelocity * passedTimeInS);
        }
        return _results;
      },
      update: function(bodies, passedTimeInS, integrate) {
        integrate(bodies, passedTimeInS);
        module.integrateOrientation(bodies, passedTimeInS);
        return module.applyForces(bodies);
      }
    };
  });

  define("CollisionDetection", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      createCircle: function(radius) {
        var shape;
        return shape = {
          type: "circle",
          radius: radius
        };
      },
      buildPairs: function(shapes) {
        var entityIdA, entityIdB, entityUsed, pairs, shapeA, shapeB;
        entityUsed = {};
        pairs = [];
        for (entityIdA in shapes) {
          shapeA = shapes[entityIdA];
          entityUsed[entityIdA] = true;
          for (entityIdB in shapes) {
            shapeB = shapes[entityIdB];
            if (!entityUsed[entityIdB]) {
              pairs.push([entityIdA, entityIdB]);
            }
          }
        }
        return pairs;
      },
      checkCollisions: function(potentialPairs, bodies, shapes) {
        var collision, contacts, d, distance, normal, pair, penetrationDepth, point, positionA, positionB, shapeA, shapeB, sumOfRadii, _i, _len;
        contacts = [];
        for (_i = 0, _len = potentialPairs.length; _i < _len; _i++) {
          pair = potentialPairs[_i];
          positionA = bodies[pair[0]].position;
          positionB = bodies[pair[1]].position;
          shapeA = shapes[0];
          shapeB = shapes[1];
          sumOfRadii = shapeA.radius + shapeB.radius;
          d = Vec2.copy(positionB);
          Vec2.subtract(d, positionA);
          distance = Vec2.length(d);
          collision = sumOfRadii >= distance;
          if (collision) {
            normal = Vec2.copy(d);
            Vec2.unit(normal);
            penetrationDepth = sumOfRadii - distance;
            point = Vec2.copy(normal);
            Vec2.scale(point, shapeA.radius - penetrationDepth / 2);
            Vec2.add(point, positionA);
            contacts.push({
              bodyIds: pair,
              normal: normal,
              depth: penetrationDepth,
              point: point
            });
          }
        }
        return contacts;
      }
    };
  });

  define("Rendering", [], function() {
    var module;
    return module = {
      drawFunctions: {
        "image": function(renderable, context, image) {
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation + image.orientationOffset);
          context.translate(image.positionOffset[0], image.positionOffset[1]);
          return context.drawImage(image.rawImage, 0, 0);
        },
        "circle": function(renderable, context, shape) {
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation);
          context.translate(shape.offset[0], shape.offset[1]);
          context.beginPath();
          context.arc(0, 0, shape.circle.radius, 0, Math.PI * 2, true);
          return context.stroke();
        },
        "ellipse": function(renderable, context, ellipse) {
          context.strokeStyle = ellipse.color;
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation);
          context.scale(ellipse.semiMajorAxis / ellipse.semiMinorAxis, 1);
          context.beginPath();
          context.arc(0, 0, ellipse.semiMinorAxis, 0, 2 * Math.PI, false);
          context.stroke();
          return context.closePath();
        },
        "rectangle": function(renderable, context, rectangle) {
          context.fillStyle = rectangle.color || "rgb(255,255,255)";
          return context.fillRect(renderable.position[0], renderable.position[1], rectangle.size[0], rectangle.size[1]);
        },
        "rectangleOutline": function(renderable, context, rectangle) {
          context.strokeStyle = rectangle.color || "rgb(0,0,0)";
          return context.strokeRect(renderable.position[0], renderable.position[1], rectangle.size[0], rectangle.size[1]);
        },
        "line": function(renderable, context, line) {
          context.strokeStyle = line.color || "rgb(255,255,255)";
          context.beginPath();
          context.moveTo(line.start[0], line.start[1]);
          context.lineTo(line.end[0], line.end[1]);
          context.closePath();
          return context.stroke();
        },
        "text": function(renderable, context, text) {
          context.fillStyle = text.color || "rgb(0,0,0)";
          if (text.font != null) {
            context.font = text.font;
          }
          if (text.bold != null) {
            context.font = "bold " + context.font;
          }
          return context.fillText(text.string, renderable.position[0], renderable.position[1]);
        }
      },
      createDisplay: function() {
        var canvas, context, display;
        canvas = document.getElementById("canvas");
        context = canvas.getContext("2d");
        context.translate(canvas.width / 2, canvas.height / 2);
        return display = {
          context: context,
          size: [canvas.width, canvas.height]
        };
      },
      createRenderable: function(type) {
        var renderable;
        return renderable = {
          type: type,
          resourceId: null,
          resource: null,
          position: [0, 0],
          orientation: 0
        };
      },
      render: function(drawFunctions, display, renderData, renderables) {
        var context, drawRenderable, height, renderable, resource, type, width, _i, _len, _results;
        context = display.context;
        width = display.size[0];
        height = display.size[1];
        context.clearRect(-width / 2, -height / 2, width, height);
        _results = [];
        for (_i = 0, _len = renderables.length; _i < _len; _i++) {
          renderable = renderables[_i];
          context.save();
          type = renderable.type;
          resource = renderable.resource != null ? renderable.resource : renderData[type][renderable.resourceId];
          if (resource == null) {
            throw "Resource " + renderable.resourceId + " does not exist.";
          }
          drawRenderable = drawFunctions[type];
          drawRenderable(renderable, context, resource);
          _results.push(context.restore());
        }
        return _results;
      }
    };
  });

  define("MainLoop", [], function() {
    var defaultCallNextFrame, maxPassedTimeInMs, module;
    maxPassedTimeInMs = 1000 / 30;
    defaultCallNextFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
      return window.setTimeout(f, 1000 / 60, Date.now());
    };
    return module = {
      execute: function(f, callNextFrame) {
        var mainLoop, previousTimeInMs;
        callNextFrame = callNextFrame || defaultCallNextFrame;
        previousTimeInMs = null;
        mainLoop = function(currentTimeInMs) {
          var currentTimeInS, passedTimeInMs, passedTimeInS;
          passedTimeInMs = currentTimeInMs - previousTimeInMs;
          previousTimeInMs = currentTimeInMs;
          passedTimeInMs = Math.min(passedTimeInMs, maxPassedTimeInMs);
          currentTimeInS = currentTimeInMs / 1000;
          passedTimeInS = passedTimeInMs / 1000;
          f(currentTimeInS, passedTimeInS);
          return callNextFrame(mainLoop);
        };
        return callNextFrame(mainLoop);
      }
    };
  });

  define("Input", [], function() {
    var ensureKeyNameIsValid, keyCode, keyCodesByName, keyName, keyNameArrayToKeyCodeSet, keyNamesByCode, module;
    keyNamesByCode = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause",
      20: "caps lock",
      27: "escape",
      32: "space",
      33: "page up",
      34: "page down",
      35: "end",
      36: "home",
      37: "left arrow",
      38: "up arrow",
      39: "right arrow",
      40: "down arrow",
      45: "insert",
      46: "delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z",
      91: "left window key",
      92: "right window key",
      93: "select key",
      96: "numpad 0",
      97: "numpad 1",
      98: "numpad 2",
      99: "numpad 3",
      100: "numpad 4",
      101: "numpad 5",
      102: "numpad 6",
      103: "numpad 7",
      104: "numpad 8",
      105: "numpad 9",
      106: "multiply",
      107: "add",
      109: "subtract",
      110: "decimal point",
      111: "divide",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "num lock",
      145: "scroll lock",
      186: "semi-colon",
      187: "equal sign",
      188: "comma",
      189: "dash",
      190: "period",
      191: "forward slash",
      192: "grave accent",
      219: "open bracket",
      220: "back slash",
      221: "close braket",
      222: "single quote"
    };
    keyCodesByName = {};
    for (keyCode in keyNamesByCode) {
      keyName = keyNamesByCode[keyCode];
      keyCodesByName[keyName] = parseInt(keyCode);
    }
    ensureKeyNameIsValid = function(keyName) {
      if (keyCodesByName[keyName] == null) {
        throw "\"" + keyName + "\" is not a valid key name.";
      }
    };
    keyNameArrayToKeyCodeSet = function(keyNameArray) {
      var keyCodeSet, keyName, _i, _len;
      keyCodeSet = {};
      for (_i = 0, _len = keyNameArray.length; _i < _len; _i++) {
        keyName = keyNameArray[_i];
        keyCode = keyCodesByName[keyName];
        keyCodeSet[keyCode] = true;
      }
      return keyCodeSet;
    };
    return module = {
      keyNamesByCode: keyNamesByCode,
      keyCodesByName: keyCodesByName,
      preventDefaultFor: function(keyNames) {
        var keyCodeSet;
        keyCodeSet = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keyCodeSet[keyDownEvent.keyCode]) {
            return keyDownEvent.preventDefault();
          }
        });
      },
      createCurrentInput: function() {
        var currentInput;
        currentInput = {};
        window.addEventListener("keydown", function(keyDownEvent) {
          keyName = keyNamesByCode[keyDownEvent.keyCode];
          return currentInput[keyName] = true;
        });
        window.addEventListener("keyup", function(keyUpEvent) {
          keyName = keyNamesByCode[keyUpEvent.keyCode];
          return currentInput[keyName] = false;
        });
        return currentInput;
      },
      onKeys: function(keyNames, callback) {
        var keysOfInterest;
        keysOfInterest = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keysOfInterest[keyDownEvent.keyCode]) {
            keyName = keyNamesByCode[keyDownEvent.keyCode];
            return callback(keyName, keyDownEvent);
          }
        });
      },
      isKeyDown: function(currentInput, keyName) {
        ensureKeyNameIsValid(keyName);
        return currentInput[keyName] === true;
      }
    };
  });

  define("Vec2", [], function() {
    var module;
    return module = {
      copy: function(v) {
        return [v[0], v[1]];
      },
      scale: function(v, s) {
        v[0] *= s;
        return v[1] *= s;
      },
      add: function(v1, v2) {
        v1[0] += v2[0];
        return v1[1] += v2[1];
      },
      subtract: function(v1, v2) {
        v1[0] -= v2[0];
        return v1[1] -= v2[1];
      },
      dot: function(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      },
      length: function(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      },
      squaredLength: function(v) {
        return v[0] * v[0] + v[1] * v[1];
      },
      unit: function(v) {
        var length;
        length = module.length(v);
        v[0] /= length;
        return v[1] /= length;
      },
      applyTransform: function(v, t) {
        var x, y;
        x = v[0], y = v[1];
        v[0] = x * t[0][0] + y * t[0][1] + 1 * t[0][2];
        return v[1] = x * t[1][0] + y * t[1][1] + 1 * t[1][2];
      }
    };
  });

  define("Camera", ["Mat3x3", "Vec2", "Transform2d"], function(Mat3x3, Vec2, Transform2d) {
    var module;
    return module = {
      createCamera: function() {
        var camera;
        return camera = {
          position: [0, 0],
          rotation: 0,
          zoomFactor: 1
        };
      },
      transformRenderables: function(camera, renderables) {
        var offset, r, renderable, s, t, transform, _i, _len, _results;
        offset = Vec2.copy(camera.position);
        Vec2.scale(offset, -1);
        transform = Transform2d.identityMatrix();
        t = Transform2d.translationMatrix(offset);
        r = Transform2d.rotationMatrix(camera.rotation);
        s = Transform2d.scalingMatrix(camera.zoomFactor);
        Mat3x3.multiply(transform, s);
        Mat3x3.multiply(transform, r);
        Mat3x3.multiply(transform, t);
        _results = [];
        for (_i = 0, _len = renderables.length; _i < _len; _i++) {
          renderable = renderables[_i];
          _results.push(Vec2.applyTransform(renderable.position, transform));
        }
        return _results;
      }
    };
  });

  define("Mat3x3", [], function() {
    var module;
    return module = {
      multiply: function(m1, m2) {
        var m00, m01, m02, m10, m11, m12, m20, m21, m22;
        m00 = m1[0][0];
        m01 = m1[0][1];
        m02 = m1[0][2];
        m10 = m1[1][0];
        m11 = m1[1][1];
        m12 = m1[1][2];
        m20 = m1[2][0];
        m21 = m1[2][1];
        m22 = m1[2][2];
        m1[0][0] = m00 * m2[0][0] + m01 * m2[1][0] + m02 * m2[2][0];
        m1[0][1] = m00 * m2[0][1] + m01 * m2[1][1] + m02 * m2[2][1];
        m1[0][2] = m00 * m2[0][2] + m01 * m2[1][2] + m02 * m2[2][2];
        m1[1][0] = m10 * m2[0][0] + m11 * m2[1][0] + m12 * m2[2][0];
        m1[1][1] = m10 * m2[0][1] + m11 * m2[1][1] + m12 * m2[2][1];
        m1[1][2] = m10 * m2[0][2] + m11 * m2[1][2] + m12 * m2[2][2];
        m1[2][0] = m20 * m2[0][0] + m21 * m2[1][0] + m22 * m2[2][0];
        m1[2][1] = m20 * m2[0][1] + m21 * m2[1][1] + m22 * m2[2][1];
        return m1[2][2] = m20 * m2[0][2] + m21 * m2[1][2] + m22 * m2[2][2];
      }
    };
  });

  define("ModifiedRendering", [], function() {
    var module;
    return module = {
      drawFunctions: {
        "image": function(renderable, context, image) {
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation + image.orientationOffset);
          context.translate(image.positionOffset[0], image.positionOffset[1]);
          return context.drawImage(image.rawImage, 0, 0);
        },
        "circle": function(renderable, context, shape) {
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation);
          context.translate(shape.offset[0], shape.offset[1]);
          context.beginPath();
          context.arc(0, 0, shape.circle.radius, 0, Math.PI * 2, true);
          return context.stroke();
        },
        "ellipse": function(renderable, context, ellipse) {
          context.strokeStyle = ellipse.color;
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation);
          context.scale(ellipse.semiMajorAxis / ellipse.semiMinorAxis, 1);
          context.beginPath();
          context.arc(0, 0, ellipse.semiMinorAxis, 0, 2 * Math.PI, false);
          context.stroke();
          return context.closePath();
        },
        "rectangle": function(renderable, context, rectangle) {
          context.fillStyle = rectangle.color || "rgb(255,255,255)";
          return context.fillRect(renderable.position[0], renderable.position[1], rectangle.size[0], rectangle.size[1]);
        },
        "rectangleOutline": function(renderable, context, rectangle) {
          context.lineWidth = rectangle.lineWidth || 1;
          context.strokeStyle = rectangle.color || "rgb(0,0,0)";
          return context.strokeRect(renderable.position[0], renderable.position[1], rectangle.size[0], rectangle.size[1]);
        },
        "line": function(renderable, context, line) {
          context.strokeStyle = line.color || "rgb(255,255,255)";
          context.beginPath();
          context.moveTo(line.start[0], line.start[1]);
          context.lineTo(line.end[0], line.end[1]);
          context.closePath();
          return context.stroke();
        },
        "text": function(renderable, context, text) {
          context.fillStyle = text.color || "rgb(0,0,0)";
          if (text.font != null) {
            context.font = text.font;
          }
          if (text.bold != null) {
            context.font = "bold " + context.font;
          }
          return context.fillText(text.string, renderable.position[0], renderable.position[1]);
        }
      },
      createDisplay: function() {
        var canvas, context, display;
        canvas = document.getElementById("canvas");
        context = canvas.getContext("2d");
        context.translate(canvas.width / 2, canvas.height / 2);
        return display = {
          canvas: canvas,
          context: context,
          size: [canvas.width, canvas.height]
        };
      },
      createRenderable: function(type) {
        var renderable;
        return renderable = {
          type: type,
          resourceId: null,
          resource: null,
          position: [0, 0],
          orientation: 0
        };
      },
      render: function(drawFunctions, display, renderData, renderables) {
        var context, drawRenderable, height, renderable, resource, type, width, _i, _len, _results;
        context = display.context;
        width = display.size[0];
        height = display.size[1];
        context.clearRect(-width / 2, -height / 2, width, height);
        _results = [];
        for (_i = 0, _len = renderables.length; _i < _len; _i++) {
          renderable = renderables[_i];
          context.save();
          type = renderable.type;
          resource = renderable.resource != null ? renderable.resource : renderData[type][renderable.resourceId];
          if (resource == null) {
            throw "Resource " + renderable.resourceId + " does not exist.";
          }
          drawRenderable = drawFunctions[type];
          drawRenderable(renderable, context, resource);
          _results.push(context.restore());
        }
        return _results;
      }
    };
  });

  define("ModifiedInput", [], function() {
    var ensureKeyNameIsValid, keyCode, keyCodesByName, keyName, keyNameArrayToKeyCodeSet, keyNamesByCode, module, mouseKeyCodesByName, mouseKeyNamesByCode;
    keyNamesByCode = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause",
      20: "caps lock",
      27: "escape",
      32: "space",
      33: "page up",
      34: "page down",
      35: "end",
      36: "home",
      37: "left arrow",
      38: "up arrow",
      39: "right arrow",
      40: "down arrow",
      45: "insert",
      46: "delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z",
      91: "left window key",
      92: "right window key",
      93: "select key",
      96: "numpad 0",
      97: "numpad 1",
      98: "numpad 2",
      99: "numpad 3",
      100: "numpad 4",
      101: "numpad 5",
      102: "numpad 6",
      103: "numpad 7",
      104: "numpad 8",
      105: "numpad 9",
      106: "multiply",
      107: "add",
      109: "subtract",
      110: "decimal point",
      111: "divide",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "num lock",
      145: "scroll lock",
      186: "semi-colon",
      187: "equal sign",
      188: "comma",
      189: "dash",
      190: "period",
      191: "forward slash",
      192: "grave accent",
      219: "open bracket",
      220: "back slash",
      221: "close braket",
      222: "single quote"
    };
    mouseKeyNamesByCode = {
      0: "left mouse button",
      1: "middle mouse button",
      2: "right mouse button"
    };
    keyCodesByName = {};
    for (keyCode in keyNamesByCode) {
      keyName = keyNamesByCode[keyCode];
      keyCodesByName[keyName] = parseInt(keyCode);
    }
    mouseKeyCodesByName = {};
    for (keyCode in mouseKeyNamesByCode) {
      keyName = mouseKeyNamesByCode[keyCode];
      mouseKeyCodesByName[keyName] = parseInt(keyCode);
    }
    ensureKeyNameIsValid = function(keyName) {
      if (!((keyCodesByName[keyName] != null) || (mouseKeyCodesByName[keyName] != null))) {
        throw "\"" + keyName + "\" is not a valid key name.";
      }
    };
    keyNameArrayToKeyCodeSet = function(keyNameArray) {
      var keyCodeSet, keyName, _i, _len;
      keyCodeSet = {};
      for (_i = 0, _len = keyNameArray.length; _i < _len; _i++) {
        keyName = keyNameArray[_i];
        keyCode = keyCodesByName[keyName];
        keyCodeSet[keyCode] = true;
      }
      return keyCodeSet;
    };
    return module = {
      keyNamesByCode: keyNamesByCode,
      mouseKeyNamesByCode: mouseKeyNamesByCode,
      keyCodesByName: keyCodesByName,
      mouseKeyCodesByName: mouseKeyCodesByName,
      preventDefaultFor: function(keyNames) {
        var keyCodeSet;
        keyCodeSet = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keyCodeSet[keyDownEvent.keyCode]) {
            return keyDownEvent.preventDefault();
          }
        });
      },
      createCurrentInput: function(display) {
        var currentInput;
        currentInput = {
          pressedKeys: {},
          pointerPosition: [0, 0]
        };
        window.addEventListener("keydown", function(keyDownEvent) {
          keyName = keyNamesByCode[keyDownEvent.keyCode];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("keyup", function(keyUpEvent) {
          keyName = keyNamesByCode[keyUpEvent.keyCode];
          return currentInput.pressedKeys[keyName] = false;
        });
        window.addEventListener("mousedown", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("mouseup", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = false;
        });
        display.canvas.addEventListener("mousemove", function(mouseMoveEvent) {
          currentInput.pointerPosition[0] = mouseMoveEvent.offsetX - display.size[0] / 2;
          return currentInput.pointerPosition[1] = mouseMoveEvent.offsetY - display.size[1] / 2;
        });
        return currentInput;
      },
      onKeys: function(keyNames, callback) {
        var keysOfInterest;
        keysOfInterest = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keysOfInterest[keyDownEvent.keyCode]) {
            keyName = keyNamesByCode[keyDownEvent.keyCode];
            return callback(keyName, keyDownEvent);
          }
        });
      },
      isKeyDown: function(currentInput, keyName) {
        ensureKeyNameIsValid(keyName);
        return currentInput.pressedKeys[keyName] === true;
      }
    };
  });

  define("MyModule", [], function() {
    var module;
    return module = {
      itIsAwesome: true
    };
  });

  define("Logic", ["ModifiedInput", "Entities", "Gladiators"], function(Input, Entities, Gladiators) {
    var createEntity, destroyEntity, determineWinner, entityFactories, module, resetGame;
    entityFactories = {
      "gladiator": Gladiators.createEntity
    };
    determineWinner = function(gameState, gladiators) {
      var aiGladiators, entityId, gladiator, playerGladiators;
      aiGladiators = 0;
      playerGladiators = 0;
      for (entityId in gladiators) {
        gladiator = gladiators[entityId];
        switch (gladiator.side) {
          case "ai":
            aiGladiators += 1;
            break;
          case "player":
            playerGladiators += 1;
        }
      }
      if (aiGladiators === 0) {
        gameState.winner = "player";
      }
      if (playerGladiators === 0) {
        return gameState.winner = "ai";
      }
    };
    resetGame = function(gameState, currentInput) {
      if (gameState.winner !== 0) {
        if (Input.isKeyDown(currentInput, "enter")) {
          return gameState.reset = true;
        }
      }
    };
    createEntity = null;
    destroyEntity = null;
    return module = {
      createGameState: function() {
        var gameState;
        return gameState = {
          gladiatorSelection: {
            currentlySelected: null
          },
          clickedButton: null,
          winner: null,
          reset: false,
          aiControl: {
            nextAction: 0
          },
          components: {}
        };
      },
      initGameState: function(gameState) {
        createEntity = function(type, args) {
          return Entities.createEntity(entityFactories, gameState.components, type, args);
        };
        destroyEntity = function(entityId) {
          return Entities.destroyEntity(gameState.components, entityId);
        };
        createEntity("gladiator", {
          position: [-160, -100],
          weapon: "spear",
          facing: "front",
          side: "ai"
        });
        createEntity("gladiator", {
          position: [0, -100],
          weapon: "sword",
          facing: "front",
          side: "ai"
        });
        createEntity("gladiator", {
          position: [160, -100],
          weapon: "shield",
          facing: "front",
          side: "ai"
        });
        createEntity("gladiator", {
          position: [-160, 100],
          weapon: "spear",
          facing: "back",
          side: "player"
        });
        createEntity("gladiator", {
          position: [0, 100],
          weapon: "sword",
          facing: "back",
          side: "player"
        });
        return createEntity("gladiator", {
          position: [160, 100],
          weapon: "shield",
          facing: "back",
          side: "player"
        });
      },
      updateGameState: function(gameState, currentInput, timeInS, passedTimeInS) {
        Gladiators.applyInput(currentInput, gameState.components.gladiators, gameState.components.positions, gameState.gladiatorSelection);
        Gladiators.handleActions(gameState, gameState.components.gladiators, gameState.components.positions);
        Gladiators.updateActions(gameState.components.gladiators, passedTimeInS);
        Gladiators.killGladiators(gameState.components.gladiators, destroyEntity);
        Gladiators.updateAi(gameState.components.gladiators, gameState.components.positions, gameState.aiControl, passedTimeInS);
        determineWinner(gameState, gameState.components.gladiators);
        return resetGame(gameState, currentInput);
      }
    };
  });

  define("Game", ["Images", "ModifiedRendering", "ModifiedInput", "MainLoop", "Logic", "Graphics"], function(Images, Rendering, Input, MainLoop, Logic, Graphics) {
    var imagePaths;
    imagePaths = ["images/gladiator-front.png", "images/spear-front.png", "images/sword-front.png", "images/shield-front.png", "images/gladiator-back.png", "images/spear-back.png", "images/sword-back.png", "images/shield-back.png"];
    return Images.loadImages(imagePaths, function(rawImages) {
      var currentInput, display, gameState, images, renderData, renderState;
      images = Images.process(rawImages);
      renderData = {
        "image": images
      };
      Rendering.drawFunctions["text"] = function(renderable, context, text) {
        var xPos, yPos;
        context.fillStyle = text.textColor || "rgb(0,0,0)";
        if (text.font != null) {
          context.font = text.font;
        }
        if (text.bold != null) {
          context.font = "bold " + context.font;
        }
        xPos = text.centered[0] ? renderable.position[0] - context.measureText(text.string).width / 2 : renderable.position[0];
        yPos = text.centered[1] ? renderable.position[1] + text.size / 2 : renderable.position[1];
        context.fillText(text.string, xPos, yPos);
        if (text.border) {
          context.strokeStyle = text.borderColor;
          context.lineWidth = text.borderWidth;
          return context.strokeText(text.string, xPos, renderable.position[1]);
        }
      };
      Rendering.drawFunctions["filledCircle"] = function(renderable, context, circle) {
        context.fillStyle = circle.color;
        context.beginPath();
        context.arc(renderable.position[0], renderable.position[1], circle.radius, 0, 2 * Math.PI, false);
        context.fill();
        return context.closePath();
      };
      Input.preventDefaultFor(["up arrow", "down arrow", "left arrow", "right arrow", "space"]);
      display = Rendering.createDisplay();
      currentInput = Input.createCurrentInput(display);
      gameState = Logic.createGameState();
      renderState = Graphics.createRenderState();
      Logic.initGameState(gameState);
      return MainLoop.execute(function(currentTimeInS, passedTimeInS) {
        Logic.updateGameState(gameState, currentInput, currentTimeInS, passedTimeInS);
        Graphics.updateRenderState(renderState, gameState, currentInput, passedTimeInS);
        Rendering.render(Rendering.drawFunctions, display, renderData, renderState.renderables);
        if (gameState.reset) {
          gameState = Logic.createGameState();
          Logic.initGameState(gameState);
          return renderState = Graphics.createRenderState();
        }
      });
    });
  });

  define("Graphics", ["Rendering", "Camera", "Vec2", "Gladiators", "Tools", "ModifiedInput"], function(Rendering, Camera, Vec2, Gladiators, Tools, Input) {
    var actionButtonOffset, actionButtonSize, actionTexts, appendAction, appendActionButton, appendActionButtons, appendBar, appendGladiator, appendGladiatorSelection, appendGladiators, appendHealthBar, appendWeapon, appendWinnerNotice, applyGladiatorAnimation, attackButtonOffset, blockButtonOffset, module, selectionOffset, weaponOffsets;
    weaponOffsets = {
      "spear": {
        front: [-6, 8],
        back: [6, 8]
      },
      "sword": {
        front: [-4, -4],
        back: [4, -4]
      },
      "shield": {
        front: [0, 4],
        back: [0, 4]
      }
    };
    actionTexts = {
      "ready": "Ready!",
      "attack": "Attacking...",
      "block": "Blocking...",
      "cooldown": ""
    };
    selectionOffset = Vec2.copy(Gladiators.selectionRectangleSize);
    Vec2.scale(selectionOffset, 0.5);
    appendBar = function(renderables, centerPosition, maxWidth, width, height, color) {
      var bar, border, position;
      position = Vec2.copy(centerPosition);
      Vec2.add(position, [-maxWidth / 2, 0]);
      bar = Rendering.createRenderable("rectangle");
      bar.position = position;
      bar.resource = {
        size: [width, height],
        color: color
      };
      border = Rendering.createRenderable("rectangleOutline");
      border.position = position;
      border.resource = {
        size: [maxWidth, height],
        color: "rgb(0,0,0)"
      };
      renderables.push(bar);
      return renderables.push(border);
    };
    applyGladiatorAnimation = function(gladiator, position, gladiatorId, targetPosition, animations, passedTimeInS) {
      var animation, animationOffset, scaleFactor, t;
      if (gladiator.action === "cooldown") {
        if (animations[gladiatorId] == null) {
          animations[gladiatorId] = {
            time: 0
          };
        }
        animation = animations[gladiatorId];
        animation.time += passedTimeInS;
        animationOffset = Vec2.copy(targetPosition);
        Vec2.subtract(animationOffset, position);
        Vec2.scale(animationOffset, 0.75);
        t = gladiator.charge / Gladiators.maxChargeByAction["cooldown"];
        scaleFactor = t <= 0.5 ? t * 2 : 1 - (t - 0.5) * 2;
        Vec2.scale(animationOffset, scaleFactor);
        return Vec2.add(position, animationOffset);
      }
    };
    appendGladiator = function(renderables, position, gladiator, gladiatorId, targetPosition, animations, passedTimeInS) {
      var renderable;
      applyGladiatorAnimation(gladiator, position, gladiatorId, targetPosition, animations, passedTimeInS);
      renderable = Rendering.createRenderable("image");
      renderable.resourceId = "images/gladiator-" + gladiator.facing + ".png";
      renderable.position = position;
      return renderables.push(renderable);
    };
    appendWeapon = function(renderables, weapon, facing, gladiatorPosition) {
      var offset, position, renderable;
      renderable = Rendering.createRenderable("image");
      renderable.resourceId = "images/" + weapon + "-" + facing + ".png";
      position = Vec2.copy(gladiatorPosition);
      offset = weaponOffsets[weapon][facing];
      Vec2.add(position, offset);
      renderable.position = position;
      return renderables.push(renderable);
    };
    appendHealthBar = function(renderables, gladiator, gladiatorPosition) {
      var color, height, maxWidth, position, width;
      position = Vec2.copy(gladiatorPosition);
      Vec2.add(position, [0, -60]);
      maxWidth = 60;
      width = maxWidth * gladiator.health / Gladiators.maxHealth;
      height = 20;
      color = "rgb(255,0,0)";
      return appendBar(renderables, position, maxWidth, width, height, color);
    };
    appendAction = function(renderables, gladiator, gladiatorPosition) {
      var barPosition, color, height, maxChargeForAction, maxWidth, normWidth, status, statusPosition, width;
      if (!(gladiator.side === "ai" && gladiator.action === "ready")) {
        statusPosition = Vec2.copy(gladiatorPosition);
        Vec2.add(statusPosition, [0, 50]);
        color = gladiator.action === "ready" ? "rgb(0,255,0)" : "rgb(0,0,0)";
        status = Rendering.createRenderable("text");
        status.position = statusPosition;
        status.resource = {
          string: actionTexts[gladiator.action],
          centered: [true, false],
          border: false,
          font: "bold 13pt Arial Black",
          textColor: color,
          borderColor: "rgb(0,0,0)",
          borderWidth: 2
        };
        renderables.push(status);
      }
      if (!(gladiator.action === "ready" || gladiator.action === "cooldown")) {
        barPosition = Vec2.copy(statusPosition);
        Vec2.add(barPosition, [0, 8]);
        maxChargeForAction = Gladiators.maxChargeByAction[gladiator.action];
        normWidth = 80;
        maxWidth = maxChargeForAction / Gladiators.maxCharge * normWidth;
        width = gladiator.charge / maxChargeForAction * maxWidth;
        height = 7;
        color = "rgb(255,255,255)";
        return appendBar(renderables, barPosition, maxWidth, width, height, color);
      }
    };
    appendGladiators = function(renderables, gladiators, positions, animations, passedTimeInS) {
      var entityId, gladiator, position, _results;
      _results = [];
      for (entityId in gladiators) {
        gladiator = gladiators[entityId];
        position = Vec2.copy(positions[entityId]);
        appendGladiator(renderables, position, gladiator, entityId, gladiator.targetPosition, animations, passedTimeInS);
        appendWeapon(renderables, gladiator.weapon, gladiator.facing, position);
        appendHealthBar(renderables, gladiator, position);
        _results.push(appendAction(renderables, gladiator, position));
      }
      return _results;
    };
    appendGladiatorSelection = function(renderables, gladiators, positions) {
      var color, entityId, gladiator, position, selection, selectionPosition, _results;
      _results = [];
      for (entityId in gladiators) {
        gladiator = gladiators[entityId];
        if (gladiator.side === "player") {
          if (gladiator.highlighted || gladiator.selected) {
            position = positions[entityId];
            color = gladiator.selected ? "rgb(255,255,255)" : "rgb(0,0,0)";
            selectionPosition = Vec2.copy(position);
            Vec2.subtract(selectionPosition, selectionOffset);
            selection = Rendering.createRenderable("rectangleOutline");
            selection.position = selectionPosition;
            selection.resource = {
              size: Gladiators.selectionRectangleSize,
              color: color
            };
            _results.push(renderables.push(selection));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    actionButtonSize = [60, 20];
    actionButtonOffset = Vec2.copy(actionButtonSize);
    Vec2.scale(actionButtonOffset, -0.5);
    attackButtonOffset = [0, 0];
    blockButtonOffset = [0, 30];
    appendActionButton = function(renderables, currentInput, text, center, active, gameState, buttonType, gladiatorId) {
      var alpha, border, button, buttonText, pointerOverButton, position;
      alpha = (function() {
        switch (active) {
          case true:
            return "1.0";
          case false:
            return "0.5";
        }
      })();
      position = Vec2.copy(center);
      Vec2.add(position, actionButtonOffset);
      button = Rendering.createRenderable("rectangle");
      button.position = position;
      button.resource = {
        size: actionButtonSize,
        color: "rgb(255,255,0)"
      };
      buttonText = Rendering.createRenderable("text");
      buttonText.position = center;
      buttonText.resource = {
        string: text,
        centered: [true, true],
        font: "bold 13pt Arial Black",
        textColor: "rgba(0,0,0," + alpha + ")",
        size: 13,
        border: false,
        borderColor: "rgb(0,0,0)",
        borderWidth: 2
      };
      renderables.push(button);
      renderables.push(buttonText);
      pointerOverButton = Tools.pointInRectangle(currentInput.pointerPosition, center, actionButtonSize);
      if (pointerOverButton && active) {
        border = Rendering.createRenderable("rectangleOutline");
        border.position = position;
        border.resource = {
          size: actionButtonSize,
          color: "rgb(0,0,255)",
          lineWidth: 2
        };
        renderables.push(border);
        if (Input.isKeyDown(currentInput, "left mouse button")) {
          return gameState.clickedButton = {
            button: buttonType,
            gladiatorId: gladiatorId
          };
        }
      }
    };
    appendActionButtons = function(renderables, currentInput, gladiators, positions, gameState) {
      var attackButtonPosition, blockButtonActive, blockButtonPosition, entityId, gladiator, mouseOverGladiator, position, _results;
      if (gameState.gladiatorSelection.currentlySelected !== null) {
        _results = [];
        for (entityId in gladiators) {
          gladiator = gladiators[entityId];
          position = positions[entityId];
          mouseOverGladiator = Tools.pointInRectangle(currentInput.pointerPosition, position, Gladiators.selectionRectangleSize);
          if (mouseOverGladiator && gladiator.side === "ai") {
            attackButtonPosition = Vec2.copy(position);
            Vec2.add(attackButtonPosition, attackButtonOffset);
            blockButtonPosition = Vec2.copy(position);
            Vec2.add(blockButtonPosition, blockButtonOffset);
            blockButtonActive = gladiator.action === "attack";
            appendActionButton(renderables, currentInput, "Attack", attackButtonPosition, true, gameState, "attack", entityId);
            _results.push(appendActionButton(renderables, currentInput, "Block", blockButtonPosition, blockButtonActive, gameState, "block", entityId));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    appendWinnerNotice = function(renderables, winner) {
      var pressToRestart, text, youWonLost;
      if (winner !== null) {
        text = (function() {
          switch (winner) {
            case "ai":
              return "You lost!";
            case "player":
              return "You won!";
          }
        })();
        youWonLost = Rendering.createRenderable("text");
        youWonLost.position = [0, -50];
        youWonLost.resource = {
          string: text,
          centered: [true, true],
          font: "bold 45pt Arial Black",
          textColor: "rgb(0,0,0)",
          size: 45,
          border: false,
          borderColor: "rgb(0,0,0)",
          borderWidth: 2
        };
        pressToRestart = Rendering.createRenderable("text");
        pressToRestart.position = [0, 0];
        pressToRestart.resource = {
          string: "(press enter to restart)",
          centered: [true, true],
          font: "bold 25pt Arial Black",
          textColor: "rgb(0,0,0)",
          size: 25,
          border: false,
          borderColor: "rgb(0,0,0)",
          borderWidth: 2
        };
        renderables.push(youWonLost);
        return renderables.push(pressToRestart);
      }
    };
    return module = {
      createRenderState: function() {
        var renderState;
        return renderState = {
          camera: Camera.createCamera(),
          renderables: [],
          animations: {}
        };
      },
      updateRenderState: function(renderState, gameState, currentInput, passedTimeInS) {
        renderState.renderables.length = 0;
        appendGladiators(renderState.renderables, gameState.components.gladiators, gameState.components.positions, renderState.animations, passedTimeInS);
        appendGladiatorSelection(renderState.renderables, gameState.components.gladiators, gameState.components.positions);
        appendActionButtons(renderState.renderables, currentInput, gameState.components.gladiators, gameState.components.positions, gameState);
        appendWinnerNotice(renderState.renderables, gameState.winner);
        return Camera.transformRenderables(renderState.camera, renderState.renderables);
      }
    };
  });

  define("Gladiators", ["ModifiedInput", "Tools", "Vec2"], function(Input, Tools, Vec2) {
    var action, chargePerS, maxCharge, maxChargeByAction, maxChargeForAction, module, nextEntityId, weaponBlock, weaponDamage;
    nextEntityId = 0;
    maxChargeByAction = {
      "attack": 100,
      "block": 20,
      "cooldown": 20
    };
    maxCharge = 0;
    for (action in maxChargeByAction) {
      maxChargeForAction = maxChargeByAction[action];
      maxCharge = Math.max(maxCharge, maxChargeForAction);
    }
    chargePerS = 20;
    weaponDamage = {
      "spear": 30,
      "sword": 20,
      "shield": 10
    };
    weaponBlock = {
      "spear": 0.2,
      "sword": 0.4,
      "shield": 0.6
    };
    return module = {
      maxHealth: 150,
      maxChargeByAction: maxChargeByAction,
      maxCharge: maxCharge,
      selectionRectangleSize: [110, 150],
      createEntity: function(args) {
        var entity, id;
        id = nextEntityId;
        nextEntityId += 1;
        return entity = {
          id: id,
          components: {
            "positions": args.position,
            "gladiators": {
              side: args.side,
              facing: args.facing,
              health: module.maxHealth,
              weapon: args.weapon,
              target: null,
              targetPosition: null,
              highlighted: false,
              selected: false,
              action: "ready",
              charge: 0
            }
          }
        };
      },
      applyInput: function(currentInput, gladiators, positions, selection) {
        var entityId, gladiator, mouseOverGladiator, position, previouslySelected, selectionKeyDown, _results;
        _results = [];
        for (entityId in gladiators) {
          gladiator = gladiators[entityId];
          position = positions[entityId];
          mouseOverGladiator = Tools.pointInRectangle(currentInput.pointerPosition, position, module.selectionRectangleSize);
          if (mouseOverGladiator && gladiator.action === "ready") {
            gladiator.highlighted = true;
            selectionKeyDown = Input.isKeyDown(currentInput, "left mouse button");
            if (gladiator.side === "player" && selectionKeyDown) {
              previouslySelected = gladiators[selection.currentlySelected];
              if (previouslySelected != null) {
                previouslySelected.selected = false;
              }
              gladiator.selected = true;
              _results.push(selection.currentlySelected = entityId);
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(gladiator.highlighted = false);
          }
        }
        return _results;
      },
      handleActions: function(gameState, gladiators, positions) {
        var gladiator;
        if (gameState.clickedButton !== null) {
          gladiator = gladiators[gameState.gladiatorSelection.currentlySelected];
          gameState.gladiatorSelection.currentlySelected = null;
          gladiator.selected = false;
          gladiator.action = gameState.clickedButton.button;
          gladiator.target = gameState.clickedButton.gladiatorId;
          gladiator.targetPosition = Vec2.copy(positions[gladiator.target]);
        }
        return gameState.clickedButton = null;
      },
      updateActions: function(gladiators, passedTimeInS) {
        var damage, damageAfterBlock, damageBlock, enemyDamage, entityId, gladiator, target, _results;
        _results = [];
        for (entityId in gladiators) {
          gladiator = gladiators[entityId];
          if ((gladiators[gladiator.target] != null) || gladiator.action === "cooldown") {
            if (maxChargeByAction[gladiator.action] != null) {
              gladiator.charge += chargePerS * passedTimeInS;
            }
            maxCharge = maxChargeByAction[gladiator.action];
            if (gladiator.charge >= maxCharge) {
              gladiator.charge = 0;
              target = gladiators[gladiator.target];
              damage = weaponDamage[gladiator.weapon];
              switch (gladiator.action) {
                case "attack":
                  target.health -= damage;
                  break;
                case "block":
                  enemyDamage = weaponDamage[target.weapon];
                  damageBlock = weaponBlock[gladiator.weapon];
                  damageAfterBlock = enemyDamage * (1 - damageBlock);
                  target.action = "ready";
                  target.charge = 0;
                  gladiator.health -= damageAfterBlock;
              }
              gladiator.action = (function() {
                switch (gladiator.action) {
                  case "cooldown":
                    return "ready";
                  default:
                    return "cooldown";
                }
              })();
              _results.push(gladiator.target = null);
            } else {
              _results.push(void 0);
            }
          } else {
            gladiator.target = null;
            gladiator.charge = 0;
            _results.push(gladiator.action = "ready");
          }
        }
        return _results;
      },
      killGladiators: function(gladiators, destroyEntity) {
        var entityId, gladiator, _results;
        _results = [];
        for (entityId in gladiators) {
          gladiator = gladiators[entityId];
          if (gladiator.health <= 0) {
            _results.push(destroyEntity(entityId));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      updateAi: function(gladiators, positions, aiControl, passedTimeInS) {
        var allPlayerGladiators, attackProbability, attackingPlayerGladiators, blockProbability, entityId, gladiator, potentialTargets, readyAiGladiators, target;
        aiControl.nextAction -= passedTimeInS;
        if (aiControl.nextAction <= 0) {
          aiControl.nextAction = Math.random() * 3;
          attackingPlayerGladiators = [];
          allPlayerGladiators = [];
          readyAiGladiators = [];
          for (entityId in gladiators) {
            gladiator = gladiators[entityId];
            if (gladiator.side === "player") {
              allPlayerGladiators.push({
                id: entityId,
                gladiator: gladiator
              });
              if (gladiator.action === "attack") {
                attackingPlayerGladiators.push({
                  id: entityId,
                  gladiator: gladiator
                });
              }
            }
            if (gladiator.side === "ai" && gladiator.action === "ready") {
              readyAiGladiators.push({
                id: entityId,
                gladiator: gladiator
              });
            }
          }
          if (readyAiGladiators.length > 0 && allPlayerGladiators.length > 0) {
            gladiator = readyAiGladiators[Math.floor(Math.random() * readyAiGladiators.length)].gladiator;
            action = null;
            if (attackingPlayerGladiators.length > 0) {
              attackProbability = 0;
              blockProbability = 0;
              switch (gladiator.weapon) {
                case "spear":
                  attackProbability = 3;
                  blockProbability = 1;
                  break;
                case "sword":
                  attackProbability = 2;
                  blockProbability = 2;
                  break;
                case "shield":
                  attackProbability = 1;
                  blockProbability = 3;
              }
              if (Math.random() * (attackProbability + blockProbability) < attackProbability) {
                action = "attack";
              } else {
                action = "block";
              }
            } else {
              action = "attack";
            }
            target = null;
            potentialTargets = action === "block" ? attackingPlayerGladiators : allPlayerGladiators;
            target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
            gladiator.action = action;
            gladiator.target = target;
            return gladiator.targetPosition = Vec2.copy(positions[target]);
          }
        }
      }
    };
  });

  define("Tools", [], function() {
    var module;
    return module = {
      pointInRectangle: function(point, rectanglePosition, rectangleSize) {
        var maxX, maxY, minX, minY, pointerX, pointerY;
        minX = rectanglePosition[0] - rectangleSize[0] / 2;
        minY = rectanglePosition[1] - rectangleSize[1] / 2;
        maxX = rectanglePosition[0] + rectangleSize[0] / 2;
        maxY = rectanglePosition[1] + rectangleSize[1] / 2;
        pointerX = point[0];
        pointerY = point[1];
        return (minX < pointerX && pointerX < maxX) && (minY < pointerY && pointerY < maxY);
      }
    };
  });

}).call(this);
